\documentclass[12pt]{report}
\usepackage[utf8]{inputenc}
\usepackage{cite}
\usepackage[hidelinks]{hyperref}
\usepackage{graphicx}
\usepackage{amsfonts}
\usepackage{mathtools}
\usepackage{caption}
\usepackage{fancyhdr}

\pagestyle{fancy}
\fancyhf{}
\rhead{5-stage Pipelined Processor Design Report}
\lhead{\thesection}
\rfoot{\thepage}

\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}

\title{\textbf{5-stage Pipelined Processor Design Report}\\Team \#4}
\author{
  Mohamed Shawky\\
  \small\texttt{SEC:2, BN:16}
  \and
  Remonda Talaat\\
  \small\texttt{SEC:1, BN:20}
  \and
  Evram Youssef\\
  \small\texttt{SEC:1, BN:9}
  \and
  Mahmoud Adas\\
  \small\texttt{SEC:2, BN:21}
}
\date{\today}

\begin{document}

\thispagestyle{empty}

\maketitle
\tableofcontents
\listoffigures
\listoftables
\clearpage

\pagenumbering{arabic}

\part{Introduction}

\section{System Overview}
This document reports our design work of the 5-stage pipelined processor using Harvard
architecture. We discuss the overall system blocks and connections, the functionalities of the
different blocks and the hazard solutions. 

\section{Task Distribution}
\begin{center}
    \captionof{table}{Task Distribution\label{tab:td}}
 \begin{tabular}{||c| p{100mm}||} 
 \hline
 Team Member & Tasks \\ [0.5ex] 
 \hline\hline
 Mohamed Shawky & 1) Overall system design. \newline 2) Hazard detection and handling. \newline 3) Document typing and formatting. \\
 \hline
 Remonda Talaat & 1) Instruction format. \newline 2) Interrupt Handling. \newline 3) Overall system design. \\
 \hline
 Evram Youssef & 1) Control unit and its signals. \newline 2) Low level block design. \newline 3) Pipeline buffers. \\
 \hline
 Mahmoud Adas & 1) Low level block design. \newline 2) Pipeline buffers. \newline 3) Document typing and formatting. \\ 
 \hline\hline
\end{tabular}
\end{center}

\part{Overall System}

\section{Overall System Design Schema}
\begin{center}
    \begin{figure}[hp]
        \centering
        \includegraphics[width=\textwidth]{overall_system}
        \caption{Overall System Design}
        \label{fig:overall}
    \end{figure}
\end{center}

\section{Memory Specs}
\begin{itemize}
    \item We have 2 separate memory units, one for instructions and another for data and stack.
    \item Instruction Memory:
    \begin{itemize}
        \item 2$^{32}$ $X$ 16 bits
        \item 16-bit bus
    \end{itemize}
    \item Data Memory:
    \begin{itemize}
        \item 2$^{32}$ $X$ 16 bits
        \item 32-bit bus
        \item SP starts at 2$^{32}$-1
    \end{itemize}
\end{itemize}

\section{PC Control Unit}

\subsection{Inputs}
\begin{itemize}
    \item IF Flush (1 bit)
    \item Stall Signal (1 bit)
    \item RESET Signal (1 bit)
    \item Interrupt Signal (1 bit)
    \item Current OPCode (7 bits)
\end{itemize}

\subsection{Outputs}
\begin{itemize}
    \item PC Mux Selectors (3 bits)
\end{itemize}

\subsection{Logic}
\begin{itemize}
    \item If IF Flush == 1, Output = 001
    \item If RESET == 1, Output = 010
    \item If Stall == 1, Output = 011
    \item If Interrupt == 1 $||$ OPCode == RET/RTI, Output = 100
    \item Else, Output = 000
\end{itemize}

\begin{center}
    \begin{figure}[hp]
        \centering
        \includegraphics[width=0.8\textwidth]{bpu}
        \caption{Branch Prediction Unit Diagram}
        \label{fig:bpu}
    \end{figure}
\end{center}

\section{Dynamic Branch Prediction}

\subsection{Inputs}
\begin{itemize}
    \item Hashed Address (4 bits)
    \item Update Bit (1 bit): \emph{Taken or Not}  to update FSM
    \item OPcode (4 bits)
\end{itemize}

\subsection{Outputs}
\begin{itemize}
    \item Taken (1 bit): predict whether the branch taken or not
\end{itemize}

\subsection{Logic}
\begin{itemize}
    \item Updates the FSM corresponding to the hashed address.
    \item Checks whether the OPCode is of a conditional branch instruction.
    \item Outputs the prediction bit \emph{(Taken or Not)} accordingly.
\end{itemize}

\begin{center}
    \begin{figure}[hp]
        \centering
        \includegraphics[width=0.8\textwidth]{pspu}
        \caption{Stack Pointer (SP) Peak Unit Diagram}
        \label{fig:pspu}
    \end{figure}
\end{center}

\section{Stack Pointer (SP) Peak Unit}

\subsection{Inputs}
\begin{itemize}
    \item Current SP (32 bits)
    \item Prev OPCodes (3$X$7 bits)
\end{itemize}

\subsection{Outputs}
\begin{itemize}
    \item Expected SP (32 bits): stack pointer to read from after eliminating hazards
\end{itemize}

\subsection{Logic}
This unit peaks the value of the stack pointer on returning from a subroutine or an interrupt, in order to calculate the correct value of the address from which the original program counter read from memory. It checks for \emph{POP/PUSH} instructions and use the count to update the address.\\
\textbf{NOTE:} In case we didn't use this unit, we will stall the pipe for three consecutive cycles to eliminate possible hazards.

\begin{center}
    \begin{figure}[hp]
        \centering
        \includegraphics[width=0.8\textwidth]{bau}
        \caption{Branch Address Unit Diagram}
        \label{fig:bau}
    \end{figure}
\end{center}

\section{Branch Address Unit}

\subsection{Inputs}
\begin{itemize}
    \item Next PC Address (32 bits)
    \item Instruction Address (32 bits)
    \item Incremented PC Address (32 bits)
    \item Hashed Address (4 bits)
    \item OpCode (4 bits)
\end{itemize}

\subsection{Outputs}
\begin{itemize}
    \item IF Flush (1 bit)
    \item Branch Address (32 bits)
    \item Hashed Address (4 bits)
\end{itemize}

\subsection{Logic}
\begin{itemize}
    \item Check if OpCode is of a conditional branch instruction, if true:
    \begin{itemize}
        \item Check whether PC Next Address is equal to Instruction Address
        \item If true:
        \begin{itemize}
            \item IF Flush = 0, Branch Address = Instruction Address
        \end{itemize}
        \item If false:
        \begin{itemize}
            \item IF Flush = 1, Branch Address = Instruction Address
        \end{itemize}
    \end{itemize}
\end{itemize}

\begin{center}
    \begin{figure}[hp]
        \centering
        \includegraphics[width=0.8\textwidth]{reg_file}
        \caption{Register File Diagram}
        \label{fig:reg_file}
    \end{figure}
\end{center}

\section{Register File}

\subsection{Registers}
\begin{itemize}
    \item 8 general purpose registers
    \item Stack pointer (SP) register
    \item Program counter (PC) register
\end{itemize}

\subsection{Inputs}
\begin{itemize}
    \item Dest Regs: 2$X$4 bits (for destination selection)
    \item SRC Regs: 2$X$4 bits (for source selection)
    \item Fetch Reg: 4 bits (for fetch branch register selection)
    \item WB values: 2$X$32 bits (for write back values)
    \item RESET: 1 bit (for registers clear).
    \item Branch/IO: 2 bits (to determine whether the operation is IO or branch)
    \item IN Port: 32 bits (IO input port)
\end{itemize}

\subsection{Outputs}
\begin{itemize}
    \item OP1: 32 bits (value of first operand)
    \item OP2: 32 bits (value of second operand)
    \item Fetch Value: 32 bits (value of branch address required by fetch)
    \item Instruction Address: 32 bits (value of branch address)
    \item OUT Port: 32 bits (IO output port)
\end{itemize}

\subsection{Logic}
The register selector acts like a decoder to select the required operation and the register on which the operation performed.

\section{ALU}

\subsection{Inputs}
\begin{itemize}
    \item ALUop: 4 bits (refer to ALU Operations below)
    \item Operands: 2$X$32 bits (2 input operands)
\end{itemize}

\subsection{Outputs}
\begin{itemize}
    \item ALUout: 32 bits (operation result)
\end{itemize}

\subsection{ALU Operations}
\begin{itemize}
    \item 0000 $-$ NOP $-$ (no operation)
    \item 0001 $-$ INC $-$ (first operand + 1)
    \item 0010 $-$ DEC $-$ (first operand - 1)
    \item 0011 $-$ ADD $-$ (first operand + second operand)
    \item 0100 $-$ SUB $-$ (first operand - second operand)
    \item 0101 $-$ AND $-$ (first operand \&\& second operand)
    \item 0110 $-$ OR $-$ (first operand $||$ second operand)
    \item 0111 $-$ NOT $-$ (!first operand)
    \item 1000 $-$ SHL $-$ (shift first operand to the left)
    \item 1001 $-$ SHR $-$ (shift first operand to the right)
    \item 1010 $-$ INC2 $-$ (first operand + 2)
    \item 1011 $-$ DEC2 $-$ (first operand - 2)
    \item 1100 $-$ INC4 $-$ (first operand + 4)
    \item 1101 $-$ DEC4 $-$ (first operand - 4)
\end{itemize}

\subsection{Logic}
\begin{itemize}
    \item ALU performs the operation and changes the CCR accordingly.
    \item The input operands of the ALU are multiplexed between forwarded data and register data, with selectors from data forwarding unit.
\end{itemize}

\part{Instruction Format}

\section{One Operand Operations}
\begin{itemize}
    \item 4 bits (1111) for one operand instructions.
    \item 3 bits to define instruction.
    \item 3 bits for destination register.
    \item 1 bit to define the memory slots occupied by the instruction.
    \item Total of 11 bits, padded with 5 0's to fit 16 bits.
\end{itemize}
\begin{center}
    \captionof{table}{One Operand Instruction Mapping\label{tab:1op}}
 \begin{tabular}{||c| c| c| c| p{40mm}||} 
 \hline
 Operation & OpCode & Destination & 16$|$32 & Conditions  \\ [0.5ex] 
 \hline\hline
 IN & 1111000 & 000:111 & 0 & ----------------------- \\
 \hline
 NOT & 1111001 & 000:111 & 0 & if !Rdst=0,Z=1 \newline if !Rdst$<$0,N=1 \\
 \hline
 INC & 1111010 & 000:111 & 0 & if Rdst+1=0,Z=1 \newline if Rdst+1$<$0,N=1 \\
 \hline
 DEC & 1111011 & 000:111 & 0 & if Rdst-1=0,Z=1 \newline if Rdst-1$<$0,N=1 \\
 \hline
 OUT & 1111100 & 000:111 & 0 & ----------------------- \\
 \hline
\end{tabular}
\end{center}

\section{Special Operations}
\begin{itemize}
    \item 16 0's to represent NOP (0000000000000000).
\end{itemize}

\section{Two Operand Operations}
\begin{itemize}
    \item 4 bits to define instruction.
    \item 3 bits for each of Rsrc1, Rsrc2 and Rdst.
    \item 1 bit to define the memory slots occupied by the instruction.
    \item 16 bits for immediate values.
    \item Total of 14 bits in most cases with some exceptions mentioned below.
\end{itemize}
\begin{center}
    \captionof{table}{Two Operand Instruction Mapping\label{tab:1op}}
 \begin{tabular}{||c| c| c| c| c| c| c| p{30mm}||} 
 \hline
 Operation & OpCode & Rsrc1 & Rsrc2 & Rdst & imm & 16$|$32 & Conditions  \\ [0.5ex] 
 \hline\hline
 SWAP & 0001 & 000:111 & --- & 000:111 & --- & 0 & ----------------------- \\
 \hline
 ADD & 0010 & 000:111 & 000:111 & 000:111 & --- & 0 & if Result=0,Z=1 \newline if Result$<$0,N=1 \\
 \hline
 SUB & 0011 & 000:111 & 000:111 & 000:111 & --- & 0 & if Result=0,Z=1 \newline if Result$<$0,N=1 \\
 \hline
 AND & 0100 & 000:111 & 000:111 & 000:111 & --- & 0 & if Result=0,Z=1 \newline if Result$<$0,N=1 \\
 \hline
 OR & 0101 & 000:111 & 000:111 & 000:111 & --- & 0 & if Result=0,Z=1 \newline if Result$<$0,N=1 \\
 \hline
 SHL & 0110 & 000:111 & --- & --- & 16 bits & 1 & update carry flag \\
 \hline
 SHR & 0111 & 000:111 & --- & --- & 16 bits & 1 & update carry flag \\
 \hline
 IADD & 1000 & 000:111 & --- & 000:111 & 16 bits & 1 & if Result=0,Z=1 \newline if Result$<$0,N=1 \\
 \hline
\end{tabular}
\end{center}

\section{Memory Operations}
\begin{itemize}
    \item 4 bits to define instruction.
    \item 3 bits for destination register.
    \item 1 bit to define the memory slots occupied by the instruction.
    \item 16 bits for immediate values.
    \item 20 bits for effective addresses.
    \item Total of 8 bits with no immediate values or effective addresses.
    \item Total of 24 bits with immediate values.
    \item Total of 28 bits with effective addresses.
\end{itemize}
\begin{center}
    \captionof{table}{Memory Instruction Mapping\label{tab:1op}}
 \begin{tabular}{||c| c| c| c| c| c| p{40mm}||} 
 \hline
 Operation & OpCode & Rdst & imm & EA & 16$|$32 & Conditions  \\ [0.5ex] 
 \hline\hline
 PUSH & 1001 & 000:111 & --- & --- & 0 & ----------------------- \\
 \hline
 POP & 1010 & 000:111 & --- & --- & 0 & ----------------------- \\
 \hline
 LDM & 1011 & 000:111 & 16 bits & --- & 1 & ----------------------- \\
 \hline
 LDD & 1100 & 000:111 & --- & 20 bits & 1 & ----------------------- \\
 \hline
 STD & 1101 & 000:111 & --- & 20 bits & 1 & ----------------------- \\
 \hline
\end{tabular}
\end{center}

\section{Branch and Change Control Operations}
\begin{itemize}
    \item 4 bits (0000) for branching instructions.
    \item 3 bits to define instruction.
    \item 3 bits for destination register.
    \item 1 bit to define the memory slots occupied by the instruction.
    \item Total of 11 bits, padded with 5 0's to fit 16 bits. 
\end{itemize}
\begin{center}
    \captionof{table}{One Operand Instruction Mapping\label{tab:1op}}
 \begin{tabular}{||c| c| c| c| p{40mm}||} 
 \hline
 Operation & OpCode & Destination & 16$|$32 & Conditions  \\ [0.5ex] 
 \hline\hline
 JZ & 0000001 & 000:111 & 0 & ----------------------- \\
 \hline
 JMP & 0000010 & 000:111 & 0 & ----------------------- \\
 \hline
 CALL & 0000011 & 000:111 & 0 & ----------------------- \\
 \hline
 RET & 0000100 & --- & 0 & ----------------------- \\
 \hline
 RTI & 0000101 & --- & 0 & ----------------------- \\
 \hline
\end{tabular}
\end{center}

\part{Control Signals}

\section{Overview}

\begin{itemize}
    \item Control unit is responsible for generating the control signals that are used to activate several operations throughout the pipeline. Also, it's responsible for the extraction of specific information from instruction bits.
    \item It communicates with:
    \begin{itemize}
        \item IF/ID buffer for reading the instruction bits.
        \item ID/EX buffer for writing the apprpoiate Registers, AlyOP and signals.
        \item Regisger File, for Selecting the registers needed to be read (Rsrc1 and Rsrc2).
        \item Hazards Units (HDU, Branch Address Unit, SP peak Unit) for sending enables and needed signals
    \end{itemize}
    \item Its Interface:
    \begin{itemize}
        \item IN: 
        \begin{itemize}
            \item IB (32)
            \item Int bit(1)
        \end{itemize}
    
        \item OUT:
        \begin{itemize}
            \item Rsrc2_val (32) imm or EA
            \item Rsrc 1_Select (4)
            \item Rsrc 2_Select (4)
            \item Rdst 1 (4)
            \item Rdst 2 (4) //used only in case of swap
            \item BranchIO Signal (2)
            \item OP2_sel (1)
            \item SP enable (1)
            \item OpCode (7)
            \item Branch enable (1)
            \item ALU op (4)
            \item R/W memo (2)
        \end{itemize}
    \end{itemize}
    \item Notes:
    \begin{itemize}
        \item Rsrc2_val (32 bits): it takes the same place/position at the ID/EX buffer, but its used in many different ways, it could be used as a Register Value extracted form register file, it could be used as an Immediate Value extracted from IF/ID buffer, it could hold the Stack Ponter address and it could hold the Address (EA) sent to the Memory for reading or writing, all of them depends on the OpCode.
        \item Rdst_2 (4 bits): this 4 bits is only used when dealing with a SWAP operation, thus we need Op1 and Op2 and their NEW selectors, we do not swap them at decode, it is the Execute's job.
        \item Op2_Sel (1 bit): Since the position of Rsrc2 (32 bits) at the ID/Ex buffer is used in different forms (reg/imm/ea) this selector is needed.
        \item BranchIO signal (2 bits): tells the Register file what operation of these are we executing (No/In/Out/Branch), but Branch_Enable (1 bit): this enable bit interact with teh Branch Address Unit, telling it what type of OpCode are we dealing with (branching or not).
    \end{itemize}
    
\end{itemize}

\section{Signals}

\begin{itemize}
    \item Note that we've divided the operations into seven different types due to their similarities in nature:
    \begin{itemize}
        \item One Operand (not,inc,dec,out,in)
        \item Two Operands (add,sub,and,or)
        \item Imm Operand (iadd,shl,shr,ldm)
        \item Memory (ldd,std)
        \item Stacks (push,pop,call,ret,rti)
        \item Jumnpers (jz, jmp)
        \item Specials (nop,swap,reset,int)
    \end{itemize}
    \section{One Operand}
        \item Notes:
        \begin{itemize}
            \item IB[0:31]: is the instruction bits, where IB[31] is the Most Significant Bit.
            \item inserting (1111) to Rsrc/Rdst selectors tells the Register file to not output any register values.
            \item 'x' indicates don't care
            \item 0000 at the AluOP indicates no operation.
            \item note that Rsrc_1_selector is the same as Rdst_1_selector.
        \end{itemize}

        \begin{center}
            \captionof{table}{One Operand Instruction Control Signals 1\label{tab:1op}}
        \begin{tabular}{||c| c| c| c| p{40mm}||} 
        \hline
        Operation & OpCode & AluOp & Rsrc1_sel & Rsrc2_sel & Rdst1_sel & Rsrc2_val & OP2_sel  \\ [0.5ex] 
        \hline\hline
        NOT & IB[31:25] & 0111 & 0 and IB[24:22] & 1111 & 0 and IB[24:22] & x & x ----------------------- \\
        \hline
        INC & IB[31:25] & 0001 & 0 and IB[24:22] & 1111 & 0 and IB[24:22] & x & x  ----------------------- \\
        \hline
        DEC & IB[31:25] & 0010 & 0 and IB[24:22] & 1111 & 0 and IB[24:22] & x & x ----------------------- \\
        \hline
        OUT & IB[31:25] & 0000 & 0 and IB[24:22] & 1111 & 0 and IB[24:22] & x & x ----------------------- \\
        \hline
        IN  & IB[31:25] & 0000 & 0 and IB[24:22] & 1111 & 0 and IB[24:22] & x & x ----------------------- \\
        \hline

        \end{tabular}
        \end{center}

        \begin{center}
            \captionof{table}{One Operand Instruction Control Signals 2\label{tab:1op}}
        \begin{tabular}{||c| c| c| c| p{40mm}||} 
        \hline
        Operation & Rdst_2 (swap) & BranchIO & SP_enable & Branch_enable & R/W Memory  \\ [0.5ex] 
        \hline\hline
        NOT & 1111 & 00 & 0 & 0 & 00 ----------------------- \\
        \hline
        INC & 1111 & 00 & 0 & 0 & 00 ----------------------- \\
        \hline
        DEC & 1111 & 00 & 0 & 0 & 00 ----------------------- \\
        \hline
        OUT & 1111 & 01 & 0 & 0 & 00 ----------------------- \\
        \hline
        IN  & 1111 & 10 & 0 & 0 & 00 ----------------------- \\
        \hline

        \end{tabular}
        \end{center}


        \section{Two Operands}
        \item Notes:
        \begin{itemize}
            % Notes
            \item OP2_sel: 0 the register value and 1 the imm/ea value
        \end{itemize}

        \begin{center}
            \captionof{table}{Two Operands Instruction Control Signals 1\label{tab:1op}}
        \begin{tabular}{||c| c| c| c| p{40mm}||} 
        \hline
        Operation & OpCode & AluOp & Rsrc1_sel & Rsrc2_sel & Rdst1_sel & Rsrc2_val & OP2_sel  \\ [0.5ex] 
        \hline\hline
        ADD & IB[31:25] & 0011 & 0 and IB[27:25] & 0 and IB[24:22] & 0 and IB[21:19] & x & 0 ----------------------- \\
        \hline
        SUB & IB[31:25] & 0100 & 0 and IB[27:25] & 0 and IB[24:22] & 0 and IB[21:19] & x & 0 ----------------------- \\
        \hline
        AND & IB[31:25] & 0101 & 0 and IB[27:25] & 0 and IB[24:22] & 0 and IB[21:19] & x & 0 ----------------------- \\
        \hline
        OR  & IB[31:25] & 0110 & 0 and IB[27:25] & 0 and IB[24:22] & 0 and IB[21:19] & x & 0 ----------------------- \\
        \hline

        \end{tabular}
        \end{center}

        \begin{center}
            \captionof{table}{Two Operands Instruction Control Signals 2\label{tab:1op}}
        \begin{tabular}{||c| c| c| c| p{40mm}||} 
        \hline
        Operation & Rdst_2 (swap) & BranchIO & SP_enable & Branch_enable & R/W Memory  \\ [0.5ex] 
        \hline\hline
        ADD & 1111 & 00 & 0 & 0 & 00 ----------------------- \\
        \hline
        SUB & 1111 & 00 & 0 & 0 & 00 ----------------------- \\
        \hline
        AND & 1111 & 00 & 0 & 0 & 00 ----------------------- \\
        \hline
        OR  & 1111 & 00 & 0 & 0 & 00 ----------------------- \\
        \hline

        \end{tabular}
        \end{center}


        \section{Immediate Operand}
        \item Notes:
        \begin{itemize}
            % Notes
            \item note that Rsrc_1_selector is the same as Rdst_1_selector, in SHL and SHR cases, but in IADD case its a different register, and at LDM case there's no need for Rsrc it's just a destination.
            \item note that in IADD case, Rsrc != Rdst.
            \item note that in LDM case, there's no Rsrc, its a Rdst.
            \item Rsrc2_val is the immediate value extracted from the IF/ID buffer.
            \item R/W memory (11) is write and (10) is read.
            \item Sign extend Unit is used to adjust the (16 bits) immediate value to (32 bits).
            \item SE: sign extend (0/1)
        \end{itemize}

        \begin{center}
            \captionof{table}{Immediate Operand Instruction Control Signals 1\label{tab:1op}}
        \begin{tabular}{||c| c| c| c| p{40mm}||} 
        \hline
        Operation & OpCode & AluOp & Rsrc1_sel & Rsrc2_sel & Rdst1_sel & Rsrc2_val & OP2_sel  \\ [0.5ex] 
        \hline\hline
        IADD& IB[31:25] & 0011 & 0 and IB[27:25] & 1111 & 0 and IB[24:22] & 0XSE and IB[15:0] & 1 ----------------------- \\
        \hline
        SHL & IB[31:25] & 1000 & 0 and IB[27:25] & 1111 & 0 and IB[27:25] & 0XSE and IB[15:0] & 1 ----------------------- \\
        \hline
        SHR & IB[31:25] & 1001 & 0 and IB[27:25] & 1111 & 0 and IB[27:25] & 0XSE and IB[15:0] & 1 ----------------------- \\
        \hline
        LDM & IB[31:25] & 0000 & 1111 & 1111 & 0 and IB[27:25] & 0XSE and IB[15:0] & 1 ----------------------- \\
        \hline

        \end{tabular}
        \end{center}

        \begin{center}
            \captionof{table}{Immediate Operand Instruction Control Signals 2\label{tab:1op}}
        \begin{tabular}{||c| c| c| c| p{40mm}||} 
        \hline
        Operation & Rdst_2 (swap) & BranchIO & SP_enable & Branch_enable & R/W Memory  \\ [0.5ex] 
        \hline\hline
        IADD & 1111 & 00 & 0 & 0 & 00 ----------------------- \\
        \hline
        SHL & 1111 & 00 & 0 & 0 & 00 ----------------------- \\
        \hline
        SHR & 1111 & 00 & 0 & 0 & 00 ----------------------- \\
        \hline
        LDM & 1111 & 00 & 0 & 0 & 11 ----------------------- \\
        \hline

        \end{tabular}
        \end{center}



        \section{Memory}
        \item Notes:
        \begin{itemize}
            % Notes
            \item Effective address does not need a sign extend, that's why it's alway zero extended with only 12 bits.
            \item OP2_sel is 1 to pass the EA.
            \item R/W memory (11) is write and (10) is read.
        \end{itemize}

        \begin{center}
            \captionof{table}{Memory Instruction Control Signals 1\label{tab:1op}}
        \begin{tabular}{||c| c| c| c| p{40mm}||} 
        \hline
        Operation & OpCode & AluOp & Rsrc1_sel & Rsrc2_sel & Rdst1_sel & Rsrc2_val & OP2_sel  \\ [0.5ex] 
        \hline\hline
        LDD & IB[31:25] & 0000 & 0 and IB[27:25] & 1111 & 1111 & 0x000 and IB[19:0] & 1 ----------------------- \\
        \hline
        STD & IB[31:25] & 0000 & 1111 & 1111 & 0 and IB[27:25] & 0x000 and IB[19:0] & 1 ----------------------- \\
        \hline

        \end{tabular}
        \end{center}

        \begin{center}
            \captionof{table}{Memory Instruction Control Signals 2\label{tab:1op}}
        \begin{tabular}{||c| c| c| c| p{40mm}||} 
        \hline
        Operation & Rdst_2 (swap) & BranchIO & SP_enable & Branch_enable & R/W Memory  \\ [0.5ex] 
        \hline\hline
        LDD & 1111 & 00 & 0 & 0 & 10 ----------------------- \\
        \hline
        STD & 1111 & 00 & 0 & 0 & 11 ----------------------- \\
        \hline

        \end{tabular}
        \end{center}

        \section{Stacks}
        \item Notes:
        \begin{itemize}
            % Notes
            \item Rsrc2_val is the stack pointer as it's the address of the operation.
            \item AluOp Inc2 and Dec2..., are used to manipulate the Stack Ponter, thus the output of the Alu will be the new Stack Pointer.
            \item In case of Call, Rsrc1_sel is none, as no Register is used, it is the PC that is gonna be pushed at the memory.
            \item In case of Call, Rdst1_Sel, is the register holding the new address.
            \item In case of Ret and Rti, no registers are affected, as the PC is updated at the fetch stage.
            \item R/W memory (11) is write and (10) is read.
        \end{itemize}

        \begin{center}
            \captionof{table}{Stacks Instruction Control Signals 1\label{tab:1op}}
        \begin{tabular}{||c| c| c| c| p{40mm}||} 
        \hline
        Operation & OpCode & AluOp & Rsrc1_sel & Rsrc2_sel & Rdst1_sel & Rsrc2_val & OP2_sel  \\ [0.5ex] 
        \hline\hline
        PUSH & IB[31:25] & 1011 & 0 and IB[27:25] & 1111 & 1111 & SP(32 bits) & 1 ----------------------- \\
        \hline
        POP & IB[31:25] & 1010 & 1111 & 1111 & 0 and IB[27:25] & SP(32 bits) & 1 ----------------------- \\
        \hline
        CALL & IB[31:25] & 1011 & 1111 & 1111 & 0 and IB[27:25] & SP(32 bits) & 1 ----------------------- \\
        \hline
        RET & IB[31:25] & 1010 & 1111 & 1111 & 1111 & SP(32 bits) & 1 ----------------------- \\
        \hline
        RTI & IB[31:25] & 1100 & 1111 & 1111 & 1111 & SP(32 bits) & 1 ----------------------- \\
        \hline
        \end{tabular}
        \end{center}

        \begin{center}
            \captionof{table}{Stacks Instruction Control Signals 2\label{tab:1op}}
        \begin{tabular}{||c| c| c| c| p{40mm}||} 
        \hline
        Operation & Rdst_2(swap) & BranchIO & SP_enable & Branch_enable(JZ) & R/W Memory  \\ [0.5ex] 
        \hline\hline
        PUSH & 1111 & 00 & 1 & 0 & 11 ----------------------- \\
        \hline
        POP & 1111 & 00 & 0 & 0 & 10 ----------------------- \\
        \hline
        CALL & 1111 & 00 & 0 & 0 & 11 ----------------------- \\
        \hline
        RET & 1111 & 00 & 0 & 0 & 10 ----------------------- \\
        \hline
        RTI & 1111 & 00 & 0 & 0 & 10 ----------------------- \\
        \hline
        \end{tabular}
        \end{center}


        \section{Jumpers}
        \item Notes:
        \begin{itemize}
            % Notes
            \item Rsrc1_sel is the address we are jumping to, that's why we need to verify that our prediction at the JZ case is correct.
            \item BranchIO is (11) as it is a branching instruction.
            \item Branch enable (1) tp detect if the JZ operated correctly.
        \end{itemize}

        \begin{center}
            \captionof{table}{Jumpers Instruction Control Signals 1\label{tab:1op}}
        \begin{tabular}{||c| c| c| c| p{40mm}||} 
        \hline
        Operation & OpCode & AluOp & Rsrc1_sel & Rsrc2_sel & Rdst1_sel & Rsrc2_val & OP2_sel  \\ [0.5ex] 
        \hline\hline
        JMP & IB[31:25] & 0000 & 1111 & 1111 & 1111 & x & x ----------------------- \\
        \hline
        JZ & IB[31:25] & 0000 & 0 and IB[27:25] & 1111 & 1111 & x & x ----------------------- \\
        \hline
        \end{tabular}
        \end{center}

        \begin{center}
            \captionof{table}{Jumpers Instruction Control Signals 2\label{tab:1op}}
        \begin{tabular}{||c| c| c| c| p{40mm}||} 
        \hline
        Operation & Rdst_2(swap) & BranchIO & SP_enable & Branch_enable(JZ) & R/W Memory  \\ [0.5ex] 
        \hline\hline
        JMP & 1111 & 11 & 0 & 0 & 00 ----------------------- \\
        \hline
        JZ & 1111 & 11 & 0 & 1 & 00 ----------------------- \\
        \hline
        \end{tabular}
        \end{center}


        \section{Specials}
        \item Notes:
        \begin{itemize}
            % Notes
            \item SWAP: Rsrc1 = Rdst2 and Rsrc2 = Rdst1
            \item There's no Int instruction, but there's a bit called Int, sent to the Control Unit as an input.
        \end{itemize}

        \begin{center}
            \captionof{table}{Specials Instruction Control Signals 1\label{tab:1op}}
        \begin{tabular}{||c| c| c| c| p{40mm}||} 
        \hline
        Operation & OpCode & AluOp & Rsrc1_sel & Rsrc2_sel & Rdst1_sel & Rsrc2_val & OP2_sel  \\ [0.5ex] 
        \hline\hline
        NOP & IB[31:25] & 0000 & 1111 & 1111 & 1111 & x & x ----------------------- \\
        \hline
        SWAP & IB[31:25] & 0000 & 0 and IB[27:25] & 0 and IB[24:22] & 0 and IB[24:22] & x & 0 ----------------------- \\
        \hline
        Reset & IB[31:25] & 0000 & 1111 & 1111 & 1111 & x & x ----------------------- \\
        \hline
        Int & IB[31:25] & 0000 & 1111 & 1111 & 1111 & x & x ----------------------- \\
        \hline
        \end{tabular}
        \end{center}

        \begin{center}
            \captionof{table}{Specials Instruction Control Signals 2\label{tab:1op}}
        \begin{tabular}{||c| c| c| c| p{40mm}||} 
        \hline
        Operation & Rdst_2(swap) & BranchIO & SP_enable & Branch_enable(JZ) & R/W Memory  \\ [0.5ex] 
        \hline\hline
        NOP & 1111 & 00 & 0 & 0 & 00 ----------------------- \\
        \hline
        SWAP & 0 and IB[27:25] & 00 & 0 & 0 & 11 ----------------------- \\
        \hline
        Reset & 1111 & 00 & 0 & 0 & 00 ----------------------- \\
        \hline
        Int & 1111 & 00 & 0 & 0 & 00 ----------------------- \\
        \hline
        \end{tabular}
        \end{center}


\end{itemize}




\part{Pipeline Stages}

\section{Overview}
This section discusses the 5 stages of our system and their functionalities.

\subsection{Fetch Stage}
\begin{itemize}
    \item Responsible for fetching the next instruction.
    \item Can take two cycles in case of 32-bit instructions.
    \item Contains a branch prediction unit to determine the next address to be fetched in case of branching.
    \item Outputs the instruction bits into IF/ID Buffer.
    \item The current instruction is fetched at the first half of cycle, then the next PC value calculations are done in the second half.
\end{itemize}

\subsection{Decode Stage}
\begin{itemize}
    \item Responsible for decoding the instruction bits into control signals.
    \item Outputs the corresponding signals to ID/EX Buffer.
    \item Contains register file to output operand values and register-related operations.
    \item Determines the correct branch address in case of branching instructions by using Branch Address Unit.
    \item The control unit deduces the corresponding signals in the first half of cycle, then the register operations and branch address calculation are done in the second half of cycle.
\end{itemize}

\subsection{Execute Stage}
\begin{itemize}
    \item Responsible for ALU operations.
    \item Determines the correct ALU output and pass it with other signals to EX/M Buffer.
    \item The ALU operations and CCR update are done in the first half of cycle.
\end{itemize}

\subsection{Memory Stage}
\begin{itemize}
    \item Responsible for Data Memory IO.
    \item Memory read/write is done in the first half of cycle.
\end{itemize}

\subsection{Write-Back Stage}
\begin{itemize}
    \item Responsible for passing correct output values to the destination registers.
    \item Write back is done in the first half of cycle.
\end{itemize}

\section{IF/ID Buffer}

\subsection{Registers}
\begin{itemize}
    \item Instruction Register (32 bits)
    \item Next Address Register (32 bits)
    \item Incremented PC Register (32 bits)
    \item Hashed Address Register (4 bits)
    \item Interrupt Register (1 bit)
\end{itemize}

\subsection{Control Signals}
\begin{itemize}
    \item Flush: clear buffer (1 bit)
    \item Stall: freeze buffer (1 bit)
\end{itemize}

\section{ID/EX Buffer}

\subsection{Registers}
\begin{itemize}
    \item Operand Registers (2$X$32 bits)
    \item Destination Register (4 bits)
    \item OpCode Register (7 bits)
    \item R/W Register (2 bits)
\end{itemize}

\subsection{Control Signals}
\begin{itemize}
    \item Stall (IN): freeze buffer (1 bit)
    \item Destination Register (OUT) (4 bits)
    \item Output Values (OUT) (32 bits)
\end{itemize}

\section{EX/M Buffer}

\subsection{Registers}
\begin{itemize}
    \item ALUout Register (32 bits)
    \item MEM IN Register (32 bits)
    \item Opcode Register (7 bits)
    \item Destination Register (4 bits)
    \item R/W Register (2 bits)
\end{itemize}

\subsection{Control Signals}
\begin{itemize}
    \item Destination Register (OUT) (4 bits)
    \item Output Values (OUT) (32 bits)
\end{itemize}

\section{M/WB Buffer}

\subsection{Registers}
\begin{itemize}
    \item ALUout Register (32 bits)
    \item MEM OUT (32 bits)
    \item OpCode (7 bits)
    \item Destination Register (4 bits)
\end{itemize}

\part{Pipeline Hazards and solutions}

\section{Structural Hazards}

\subsection{Detection}
The structural hazard occurs in data memory and register file.

\subsection{Handling}
The structural hazard in data memory is solved by using 2 memory units, one for instructions and one for data. Both have the same specs \emph{(previously mentioned)}. \\
However structural hazard in register file is handled by forcing the write back to happen in the first half of the clock cycle and the decode to happen in the second half.

\section{Data Hazards}
\begin{center}
    \begin{figure}[hp]
        \centering
        \includegraphics[width=0.8\textwidth]{hdu}
        \caption{Hazard Detection Unit Diagram}
        \label{fig:hdu}
    \end{figure}
\end{center}

\subsection{Detection}
\subsubsection{Hazard Detection Unit (HDU)}
HDU consists of 3 parts:
\begin{itemize}
    \item \textbf{OPCode Checker:} checks the opcode of the current instruction to check whether it will cause data hazard or not, then activates the Register Comparator accordingly. Also, it checks for \emph{load-use case}, in order to activate the stall signal.
    \item \textbf{Register Comparator:} compares the decode source registers with the destination registers of the execute and memory stages.
    \item \textbf{Output Unit:} outputs stall signal in case of load and pop instructions and data forward unit enable in case of other data hazards.
\end{itemize}

\subsection{Handling}

\subsubsection{Stall}
Occurs only at Fetch and Decode stage, due to load(pop) use case.
\begin{itemize}
    \item Fetch same instruction (don't increment the program counter).
    \item Latch IF/ID buffer with the same values.
    \item Freeze Decode stage.
    \item Clear ID/EX buffer.
\end{itemize}

\subsubsection{Data Forwarding}
\begin{itemize}
    \item EX/MEM buffer $->$ Execute / Decode.
    \item ID/EX buffer $->$ Decode.
\end{itemize}

\section{Control Hazards}

\subsection{Detection}
The branch address calculation occurs in the Decode stage. So, the hazard might affect only the Fetch stage, which will be flushed in case of wrong address prediction.

\subsection{Handling}
\begin{itemize}
    \item At Fetch stage, always check the branch predictor and calculate the next address accordingly.
    \item At Decode stage, we have a \emph{Branch Address Unit} that checks whether the OPCode is of a branch operation. If so, it passes the address to the program counter and compares the correct address with the address of the counter to decide whether to flush the Fetch stage or not. 
\end{itemize}

\subsubsection{Flush}
Occurs only at Fetch Stage, due to wrong branch prediction at Decode stage.
\begin{itemize}
    \item Load new address in the program counter.
    \item Remove fetched instructions from IF/ID buffer.
\end{itemize}

\subsubsection{Dynamic Branch Prediction}
We use 2-bit branch predictor, which is a hash table of \emph{Finite State Machines} (FSMs) to predict whether the branch will be taken (1) or not (0) at each individual branch address.

\end{document}
